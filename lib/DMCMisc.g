################################################################################
# DesignMC/lib/Misc.g                                           Andy L. Drizen
#                                                                   15/02/2011
# File overview:
# 
# This file contains functions that you probably won't want to use -- I just made 
# them out of curiosity. 
#
# The ScanLotsOfImproperLFK2Ns function generates many improper L-Factorisations of 
# order n. It will look for any of them that do not have an alternating trail
# in the pair graph not including a blue edge incident with one of the vertices
#  containing L+1 red edges.
#
# The ScanLotsOfImproperLFK2NsForLeastNumberOfTrails function generates many 
# improper L-Factorisations of order n. It will look for any of them that do not 
# have an alternating trail in the discrepancy graph not including a blue edge 
# incident with one of the vertices containing L+1 red edges.
#
# The T1T2Pair function was used to help find a sequence of trades that moved from 
# a partial STS generated by <0,a,b>, to another partial STS generated by
# <0,b-a, b>. This was in hope of proving that there was always a path if you 
# allowed 2 negative blocks.. However, when v=13, a=1, b=4, it was looking 
# unhopeful, so I stopped working on this. 
# It was prompted by a paper by Drizen, Grannell and Griggs.
#
# FindMinT1T2Path, test_conditions and find_admissible functions are companions to
# the previous function.
#
# The FindBitrade function looks for trades in L-Factorisations. It does this by 
# looking at a L-Factorisation, moving around a bit until finding another proper 
# systemand then deleting any blocks that were unchanged. The first and second set 
# of blocks (removing those unaffected by the sequence of moves) is known as a 
# bitrade. We look for bitrades for many v and L. 
#
# FindLotsOfBitrades,FindBridgeToChordTrade and FindLotsOfBridgeToChordTrade are
# companions to the previous function.
#
################################################################################

BindGlobal("ScanLotsOfImproperLFK2Ns",function(n, L)
	local m, r,i;
	m:=DMCLambdaFactorisationMake(n, L);
	i:=0;
	while true do
		i:=i+1;
		m:=ManyStepsImproper(m, 200);
		while m.improper=0 do
			m:=ManyStepsImproper(m, 100);
		od;
		r:=DMCGetSpecialBlocksForImproperDesign(m);
		if Size(r)>1 then
			Print("\n",i,": ---------\n\n ",m,"\n");
			FindAlternatingTrailWithoutGivenBlueEdge(m);
			Print("\n-----------------------\n");
		fi;
	od;
end);

emptyLFfound:=[];
BindGlobal("ScanLotsOfImproperLFK2NsForLeastNumberOfTrails",function(B)
	local m, r,i,tries,j,deletableEdges, badColour,k,result,tmp, zeroHunting;
	emptyLFfound:=[];
	zeroHunting:= 0;
	if (not B.k = [2,1]) or Size(B.negatives)=0 then
		Print("This function is for DMCImproperLambdaFactorisationMake(n,l) only.\n");
		return;
	fi;
	m:=ShallowCopy(B);
	i:=0;result:=100000;
	while true do
		i:=i+1;
		
		r:=DMCGetSpecialBlocksForImproperDesign(m);
		if Size(r)>1 then
			# the next line gets the colours
			tries:=DMCMultisetDifference(DMCSortListList(Cartesian([m.negatives[1][3]], DMCMultisetDifference([m.vType[1]+1..m.vType[1]+m.vType[2]],[m.negatives[1][3]]))), DMCSortListList(r));
			Print("tries = ",tries, "\n");
			
			for j in tries do
				# now lets get the edges that we can delete
				# but first, what colour is the edge we should delete?
				badColour:=DMCMultisetDifference(j, m.negatives[1])[1];
				deletableEdges:=DMCGetBlocksContainingList(m, [badColour,m.negatives[1][1]]);
				Print("deletableEdges = ",deletableEdges, "\n");
				for k in deletableEdges do

					Print("\n Here we go!\c");
					tmp:=FindAllAlternatingTrails(m, m.negatives[1][1], m.negatives[1][2], m.negatives[1][3], badColour, [k], 0);
					if result>=tmp then
						

						if zeroHunting = 1 then
							if tmp = 0 then
								if Size(DMCComponentsOfGraph(BlockDesign(m.v, DMCMultisetDifference(m.blocks, DMCGetBlocksContainingList(m, [m.negatives[1][1], badColour]))), [m.negatives[1][2], badColour]))=DMCComponentsOfGraph(m, [m.negatives[1][1], badColour]) then
									Add(emptyLFfound, [m, m.negatives[1][3], badColour]);
									Print("\n",m,"\nNew worst: ",tmp," (forbidden edge = ",k,", col1=",m.negatives[1][3],", col2=",badColour,", start=",m.negatives[1][1],", end=",m.negatives[1][2]," #=",Size(emptyLFfound),")\n");
								fi;
				
							fi;
						else
							if result>tmp then

								Print("\n",m,"\nNew worst: ",tmp," (forbidden edge = ",k,", col1=",m.negatives[1][3],", col2=",badColour,", start=",m.negatives[1][1],", end=",m.negatives[1][2],")\n");
							fi;
						fi;
						result:=tmp;						
					fi;
				od;
			od;
		fi;
		m:=ManyStepsImproper(m, 200);
		while m.improper=false do
			m:=ManyStepsImproper(m, 100);
		od;
	od;
end);


BindGlobal("T1T2Pair",function(v,a,b)
	local blocks, i, t1, t2, check, r,path;
	blocks:=[[0,a,b]];
	for i in [1..v-1] do
		Add(blocks, (blocks[1]+i) mod v);
	od;
	blocks:=blocks+1;
	t1:=BlockDesign(v, DMCSortListList(blocks));
	t1.negatives:=[];
	t1.improper:=false;
	t1.k:=[3];

	blocks:=[[0,(b-a) mod v,b]];
	for i in [1..v-1] do
		Add(blocks, (blocks[1]+i) mod v);
	od;
	blocks:=blocks+1;
	t2:=BlockDesign(v, DMCSortListList(blocks));
	t2.negatives:=[];
	t2.improper:=false;
	t2.k:=[3];
	return [t1,t2];
end);

FoundSystems:=[];
BindGlobal("T1T2Path",function(t1,t2)
	local blocks, i, check, r,path;
	check:=false;
	path:=[t1];
	r:=t1;
	while check=false do
		
		r:=Hopper(r, [], []);
		if not r in FoundSystems then
			Add(FoundSystems, r);
			Print(Size(FoundSystems)," \c");
		fi;
		#FoundSystems:=BlockDesignIsomorphismClassRepresentatives(FoundSystems);
		
		Add(path, r);
		check:=r.blocks=t2.blocks;
	od;
	Add(path, r);
	return path;
end);

BindGlobal("FindMinT1T2Path",function(t1,t2)
	local i,k;
	i:=1000;
	while true do
		k:=T1T2Path(t1,t2);
		if Size(k)<i then
			Print(k,"\n\nnew lowest = ",Size(k),"\n");
			PrintTo("~/Desktop/lowest.g", k);
			i:=Size(k);
		fi;
	od;
end);

BindGlobal("test_conditions",function(a,b,v)
	#	Print("a = 0? ",a = 0,"\n");
	#	Print("b = 0? ",b = 0,"\n");
	#	Print("a = b? ",a = b,"\n");
	#	Print("(3*a mod v) = 0? ",(3*a mod v) = 0,"\n");
	#	Print("(3*b mod v) = 0? ",(3*b mod v) = 0,"\n");
	#	Print("b = (-2*a mod v)? ",b = (-2*a mod v),"\n");
	#	Print("b = (3*a mod v)? ",b = (3*a mod v),"\n");
	#	Print("a = (-2*b mod v)? ",a = (-2*b mod v),"\n");
	#	Print("a = (3*b mod v)? ",a = (3*b mod v),"\n");
	#	Print("(2*a mod v) = (3*b mod v)? ",(2*a mod v) = (3*b mod v),"\n");
	#	Print("(3*a mod v) = (2*b mod v)? ",(3*a mod v) = (3*b mod v),"\n");
	#	Print("a = (-b mod v)? ",a = (-b mod v),"\n");
	#	Print("(2*b mod v) = 0? ",(2*b mod v) = 0,"\n");
	#	Print("(2*a mod v) = 0? ",(2*a mod v) = 0,"\n");
	#	Print("b = (2*a mod v)? ",b = (2*a mod v),"\n");
	#	Print("a = (2*b mod v)? ",a = (2*b mod v),"\n");

	if (not (a = 0 or b=0 or a=b or (3*a mod v) = 0 or (3*b mod v) = 0 or b = (-2*a mod v) or b = (3*a mod v) or a = (-2*b mod v) or a = (3*b mod v) or (2*a mod v) = (3*b mod v) or (3*a mod v) = (2*b mod v) or a = (-b mod v) or (2*b mod v) = 0 or (2*a mod v) = 0 or b = (2*a mod v) or a = (2*b mod v) or (3*a mod v) = (3*b mod v)) ) then
		#Print("a=",a,", b=",b,"\n");
		return 1;
	else 
		return 0;
	fi;
end);


BindGlobal("find_admissible",function(v)
	local a,b;
	for a in [0..v-1] do 
		for b in [0..v-1] do 
			if test_conditions(a,b,v)=1 and DMCIsBlockDesignPartialSTS(T1T2Pair(v,a,b)[1])=1 and DMCIsBlockDesignPartialSTS(T1T2Pair(v,a,b)[2])=1 then 
				Print("a=",a," b=",b,"\n"); 
			fi; 
		od;
	od; 
end);

BindGlobal("FindBitrade",function(B)
	local B1,B2,T1,T2,T1B, T2B, SharedBlocks;
	B1:=ShallowCopy(B);
	B2:=OneStep(B1);
	T1:=DMCListListMutableCopy(B1.blocks);
	T2:=DMCListListMutableCopy(B2.blocks);
	SharedBlocks:=DMCMultisetIntersection(T1,T2);
	T1:=DMCMultisetDifference(T1, SharedBlocks);
	T2:=DMCMultisetDifference(T2, SharedBlocks);
	if not (T1=[] and T2=[]) then
		T1B:=BlockDesign(B1.v, T1);
		T2B:=BlockDesign(B1.v, T2);
		T1B.negatives:=[];
		T1B.k:=B1.k;
		T2B.k:=B1.k;
		T1B.vType:=B1.vType;
		T2B.vType:=B1.vType;
		T2B.negatives:=[];
		
		return [T1B, T2B];
	else
		return 0;
	fi;
	
end);

bitrades:=[];
BindGlobal("FindLotsOfBitrades",function(B, numPoints)
	local B2, tmpB, iterator,flag;
	B2:=ShallowCopy(B);
	while true do
		B2:=OneStep(B2);
		tmpB:=FindBitrade(B2);
		if not tmpB = 0 then
			flag:=0;
			for iterator in bitrades do
					if (IsIsomorphicBlockDesign(tmpB[1], iterator[1]) and IsIsomorphicBlockDesign(tmpB[2], iterator[2])) or (IsIsomorphicBlockDesign(tmpB[2], iterator[1]) and IsIsomorphicBlockDesign(tmpB[1], iterator[2])) then
						flag:=1;
						break;
					fi;
			od;
			if flag = 0 then
				if Size(tmpB[1].blocks) <= numPoints then
					Add(bitrades, tmpB);
					Print("Number of non-isomorphic bitrades found: ",Size(bitrades),"\n");
					Print(Collected(List(bitrades, x-> Size(x[1].blocks) )),"\n\n");
				fi;
			fi;
		fi;
	od;
end);

BindGlobal("FindBridgeToChordTrade",function(B)
	local B2,common_blocks,t1,t2,flag,i;
	flag:=0;
	B2:=ShallowCopy(B);
	for i in DMCGetSpecialBlocksForImproperDesign(B) do
		if IsChordedDG(B2, i) then
			flag:=1; break;
		fi;
	od;
	if flag=1 then
		Print("This function requires a totally bridged improper STS.\n");
		return false;
	fi;
	while flag=0 do
		B2:=ManyStepsImproper(B2,Random([1,2,3]));
		for i in DMCGetSpecialBlocksForImproperDesign(B2) do
			if IsChordedDG(B2, i) then
				flag:=1; 
				break;
			fi;
		od;
	od;
	common_blocks:=DMCMultisetIntersection(B2.blocks, B.blocks);
	if Size(common_blocks)<Size(B.blocks) then
		t1:=BlockDesign(B.v, DMCMultisetDifference(B.blocks, common_blocks));
		t2:=BlockDesign(B.v, DMCMultisetDifference(B2.blocks, common_blocks));
		t1.negatives:=B.negatives;
		t2.negatives:=B2.negatives;
	
		t1.k:=B.k;
		t2.k:=B.k;
		t1.vType:=B.vType;
		t2.vType:=B.vType;
		return [t1,t2];
	else 
		return false;
	fi;
end);

imp_bitrades:=[];
BindGlobal("FindLotsOfBridgeToChordTrade",function(B, numPoints)
	local B2, tmpB, iterator,flag,it;
	it:=0;
	imp_bitrades:=[];
	B2:=ShallowCopy(B);
	while true do
		it:=it+1;
		#B2:=ManyStepsImproper(B2);
		tmpB:=FindBridgeToChordTrade(B2);
		if not tmpB = false then
			flag:=0;
			for iterator in imp_bitrades do
					if (IsIsomorphicBlockDesign(tmpB[1], iterator[1]) and IsIsomorphicBlockDesign(tmpB[2], iterator[2])) or (IsIsomorphicBlockDesign(tmpB[2], iterator[1]) and IsIsomorphicBlockDesign(tmpB[1], iterator[2])) then
						flag:=1;
						break;
					fi;
			od;
			if flag = 0 then
				if Size(tmpB[1].blocks) <= numPoints then
					Add(imp_bitrades, tmpB);
					Print(": Number of non-isomorphic imp_bitrades found: ",Size(imp_bitrades),"\n");
					Print(Collected(List(imp_bitrades, x-> Size(x[1].blocks) )),"\n\n");
				fi;
			fi;
		fi;
		# Progress Bar
		DMCShowProgressIndicator(it);
	od;
end);
